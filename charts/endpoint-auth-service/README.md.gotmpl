{{ template "chart.header" . }}
{{ template "chart.versionBadge" . }}{{ template "chart.appVersionBadge" . }}
{{ template "chart.description" . }}

{{ template "chart.maintainersSection" . }}

## Additional Information

The chart contains the [endpoint-auth-service](https://github.com/FIWARE/endpoint-auth-service) and components to add the sidecar proxy to target services.

### Components

The chart deploys the following components:
* the [endpoint-configuartion-service](https://github.com/FIWARE/endpoint-auth-service/tree/initial-dev/src/endpoint-configuration-service) - configuration under the key "configService"
* (optional) the [configmap-updater](https://github.com/FIWARE/endpoint-auth-service/tree/initial-dev/src/envoy-configmap-updater) - automatically updates the [configmap](./templates/configmap.yaml) to be used by the proxy
* (optional) the sidecar-injector - automatically injects the sidecar-proxy, configuration under the key "sidecarInjector"
* (optional) the [ishare-auth-provider](https://github.com/FIWARE/endpoint-auth-service/tree/initial-dev/src/ishare-auth-provider) - configuration under the key "ishare"

### Sidecar-injection

The chart provides the capability to automatically inject the sidecar-proxy into pods. It makes use of [Mutating Admission Webhooks](https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/).
The webhook gets executed on pod-creation and injects the sidecar, its init-containers and the volumes into the pod.

The injected elements are:
* the (container) [envoy-proxy](https://www.envoyproxy.io)
* the (container) [resource-updater](https://github.com/FIWARE/endpoint-auth-service/tree/initial-dev/src/envoy-resource-updater) to trigger config reloads for envoy
* the (initContainer) [init-iptables](https://github.com/FIWARE/endpoint-auth-service/tree/initial-dev/src/iptables-init) to redirect traffic to the proxy
* the (initContaienr) [resource-updater](https://github.com/FIWARE/endpoint-auth-service/tree/initial-dev/src/envoy-resource-updater) to fill the initial-config-folder
* the (volume) envoy-configmap that mounts the config-map generated by the endpoint-configuration-service
* the (volume) envoy-config-folder that is shared between envoy and the resource-updater

Since the [injection-service](https://github.com/tumblr/k8s-sidecar-injector) does require certificate authentication, you should generate a cert/key as following:
(replace <sidecarInjector.fullname> with the name of the injector service)
```shell
openssl genrsa -out ca.key 2048
export COMMON_NAME=<sidecarInjector.fullname>
openssl req -x509 -new -nodes -key ca.key -subj "/CN=${COMMON_NAME}" -days 3650 -reqexts v3_req -extensions v3_ca -out ca.crt
```
and provide them under ```sidecarInjector.cert``` and ```sidecarInjector.key``` .

To select the pods that should get injected, they need to be annotated. The annotation-namespace can be configured via ```sidecarInjector.annotationNamespace```.
In addition to the namespace, ```request``` has to be added and the configuration-key ```envoy-sidecar``` needs to be set as its value.

An example would look like:

```yaml
  apiVersion: apps/v1
  kind: Deployment
    metadata:
      name: echo-server
  template:
    metadata:
      annotations:
        sidecar.k8s.fiware.org/request: "envoy-sidecar"
    spec:
      containers:
        - image: k8s.gcr.io/echoserver:1.4     
```

In order to allow proper namespace restrictions, the webhook can be restricted to certain namespaces with the configuration under the key ```sidecarInjector.restrictNamespace```.

With this example configuration:
```yaml
    sidecarInjector:
      restrictNamespace:
        enabled: true
        label: sidecar-injection
        value: enabled
```
only pods in namespaces labeled with ```sidecar-injection=enabled``` will get injected. The label can be applied via ```kubectl label namespace my-namespace sidecar-injection=enabled```

### Service Mesh compatibility

In its current version, the injected proxy will most probably(except some edge-cases) break any integration of the injected pod with a service-mesh like [istio](https://istio.io/)
or [linkerd](https://linkerd.io/), since they use similar iptables to redirect traffic to their own proxies. If the injected init-container sets up the iptables to forward every outgoing traffic
the sidecar-proxy, this will be disturbed. It's planned to offer native support for at least istio in the future(contributions for any mesh are welcome), but
for now only workarounds might be a possibility.

A potential workaround might be to setup the iptables, so that the traffic from the sidecar proxy does not directly get returned, but instead is also redirected to the mesh-proxy. Check the [init-iptables container](https://github.com/FIWARE/endpoint-auth-service/tree/initial-dev/src/iptables-init)
for that.

{{ template "chart.sourcesSection" . }}

{{ template "chart.valuesSection" . }}

{{ template "helm-docs.versionFooter" . }}